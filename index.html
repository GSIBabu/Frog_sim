<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ბაყაყის სუნთქვის სიმულაცია</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f7f0; /* Softer green background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
            min-height: 100vh;
        }

        .simulation-container {
            display: flex;
            gap: 30px; /* Increased gap */
            background-color: #fdfdfd; /* Slightly off-white */
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.12);
            max-width: 1200px; /* Limit overall width */
            width: 100%;
        }

        .controls-panel {
            flex: 0 0 250px; /* Fixed width for controls */
            background-color: #fffaf2; /* Warmer off-white */
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .controls-panel h2 {
            text-align: center;
            margin-top: 0;
            color: #2a5b3e; /* Dark green */
        }

        .simulation-area {
            flex: 3; /* Give simulation area more weight */
            display: flex;
            flex-direction: column;
            align-items: center; /* Center content horizontally */
        }

        .view-toggle-buttons {
            margin-bottom: 15px;
            display: block; /* Ensure it takes available width */
            text-align: center; /* Center the inline-block buttons */
        }

        .view-toggle-buttons button {
             display: inline-block; /* Ensure buttons sit side-by-side */
             padding: 8px 15px;
             margin: 0 5px;
             border: 1px solid #ccc;
             border-radius: 5px;
             background-color: #f0f0f0;
             cursor: pointer;
             font-weight: bold;
        }
         .view-toggle-buttons button.active {
             background-color: #4CAF50; /* Green */
             color: white;
             border-color: #4CAF50;
         }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px; /* Increased gap */
            margin-bottom: 20px; /* Increased margin */
            width: 100%;
            max-width: 600px; /* Limit dashboard width */
            background-color: #e6f2ff; /* Light blue background */
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #c0d9ff; /* Lighter blue border */
        }

        .metric {
            text-align: center;
            background-color: #ffffff;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .metric-name {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 5px;
        }
        .metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2a5b3e; /* Dark green */
        }

        .canvas-container {
            position: relative; /* For potential overlays */
            width: 100%;
            max-width: 600px; /* Match dashboard width */
            aspect-ratio: 16 / 9; /* Maintain aspect ratio */
            background-color: #e0e8e0; /* Different shade for contrast */
            border: 1px solid #b0c0b0;
            border-radius: 5px;
            margin-bottom: 15px; /* Space below canvas */
            overflow: hidden; /* Ensure content stays within border */
        }

        canvas {
            display: block; /* Remove potential extra space below canvas */
            width: 100%;
            height: 100%;
        }

        .control-group {
            margin-bottom: 20px; /* Increased spacing */
            display: flex; /* Enable flexbox */
            flex-direction: column; /* Stack label and control vertically */
            align-items: center; /* Center items horizontally */
        }
        label {
            display: block;
            margin-bottom: 8px; /* Increased spacing */
            font-weight: bold;
            font-size: 0.95em;
            text-align: center; /* Center label text */
        }
        input[type="range"] {
            width: 90%; /* Slightly less than full width */
        }
        button.toggle-button {
            width: 90%; /* Match slider width */
            padding: 10px;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #e7e7e7;
            cursor: pointer;
            font-weight: 500; /* Slightly bolder */
        }
        button.toggle-button.on {
            background-color: #64a864; /* Softer Green */
            color: white;
            border-color: #508a50;
        }
        button.toggle-button.off {
             background-color: #d47777; /* Softer Red */
             color: white;
             border-color: #b05050;
        }
        .particle-toggles {
            margin-top: 10px;
        }
        .particle-toggles button {
            padding: 5px 10px;
            margin-right: 5px;
            font-size: 0.8em;
        }

        /* Initially hide the skin-specific toggles */
        .skin-specific-controls {
             display: none;
        }

        /* --- Mobile Adjustments --- */
        @media (max-width: 768px) {
            body, html {
                height: 100%; /* Needed for percentage heights */
                overflow: hidden; /* Prevent body scroll */
            }
            .simulation-container {
                flex-direction: column;
                align-items: center; 
                padding: 15px;
                gap: 0; /* No gap needed with this layout */
                height: 100%; /* Make container fill height */
                overflow: hidden; /* Prevent container scroll */
            }

            .main-content-wrapper {
                 width: 100%;
                 height: 100%; /* Make wrapper fill container */
                 display: flex; 
                 flex-direction: column;
                 overflow: hidden; /* Prevent wrapper scroll */
            }

            .simulation-area {
                width: 100%;
                order: 1; 
                flex-shrink: 0; /* Prevent shrinking */
                /* position: sticky; */ /* Sticky might work better sometimes */
                /* top: 0; */
                /* background: #fdfdfd; */ /* Add background if needed for sticky */
                /* z-index: 1; */
            }

            .controls-panel {
                flex: 1 1 auto; 
                width: 100%; /* Use full width */
                max-width: 100%; /* Override desktop max-width */
                order: 2; 
                margin-top: 0; /* Remove top margin */
                overflow-y: auto; /* Enable vertical scrolling */
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
                 padding-bottom: 50px; /* Add padding at bottom */
            }

             .canvas-container {
                 max-width: 100%; /* Allow canvas to use full width */
             }
        }

    </style>
</head>
<body>
    <div class="simulation-container">
        <!-- Controls Panel remains outside the main content wrapper for desktop view -->
        <div class="controls-panel">
            <h2>მართვის პანელი</h2>

            <div class="control-group">
                <label for="submerge">ბაყაყის ჩაძირვა</label>
                <button id="submerge-toggle" class="toggle-button off">ჩაძირული: არა</button>
            </div>

            <div class="control-group">
                <label for="mucus">ლორწოს ფენა</label>
                <button id="mucus-toggle" class="toggle-button off">ლორწო: არა</button>
            </div>

            <div class="control-group">
                <label for="temp">გარე ტემპერატურა (°C)</label>
                <input type="range" id="temp" min="0" max="40" value="20" step="1">
                <span id="temp-value">20°C</span>
            </div>

            <!-- Skin Specific Controls - Initially Hidden -->
            <div class="control-group skin-specific-controls">
                <label>სისხლძარღვები</label>
                <button id="vessels-toggle" class="toggle-button on">ძარღვები: კი</button>
            </div>
             <div class="control-group skin-specific-controls particle-toggles">
                 <label>აირის ნაწილაკები:</label>
                 <button id="o2-toggle" class="toggle-button on">O₂: კი</button>
                 <button id="co2-toggle" class="toggle-button on">CO₂: კი</button>
             </div>

        </div>

        <!-- Wrapper for Simulation Area - will be used for mobile layout -->
        <div class="main-content-wrapper">
        <div class="simulation-area">
            <div class="view-toggle-buttons">
                     <button id="view-frog" class="active">მთლიანი ბაყაყი</button>
                     <button id="view-skin">კანის განივი კვეთა</button>
            </div>

            <div class="dashboard">
                <div class="metric">
                        <div class="metric-name">კანით სუნთქვა %</div>
                    <div class="metric-value" id="skin-resp-value">20%</div>
                </div>
                <div class="metric">
                        <div class="metric-name">ფილტვით სუნთქვა %</div>
                    <div class="metric-value" id="lung-resp-value">80%</div>
                </div>
                <div class="metric">
                        <div class="metric-name">სხეულის ტემპ.</div>
                    <div class="metric-value" id="body-temp-value">20.0°C</div>
                </div>
            </div>

            <div class="canvas-container">
                 <!-- Canvas for Whole Frog View -->
                 <canvas id="frog-canvas"></canvas>
                 <!-- Canvas for Skin Cross-Section View (initially hidden) -->
                 <canvas id="skin-canvas" style="display: none;"></canvas>
            </div>

             <div id="skin-info" style="display: none; text-align: center; margin-top: 10px;">
                     <!-- <p>კანის კვეთის მართვის ღილაკები ხელმისაწვდომია მარცხენა პანელზე.</p> -->
             </div>

        </div>
        </div>

    </div>

    <script>
        // --- DOM Element References ---
        const frogCanvas = document.getElementById('frog-canvas');
        const skinCanvas = document.getElementById('skin-canvas');
        const frogCtx = frogCanvas.getContext('2d');
        const skinCtx = skinCanvas.getContext('2d');

        const viewFrogButton = document.getElementById('view-frog');
        const viewSkinButton = document.getElementById('view-skin');

        const submergeToggle = document.getElementById('submerge-toggle');
        const mucusToggle = document.getElementById('mucus-toggle');
        const tempSlider = document.getElementById('temp');
        const tempValueDisplay = document.getElementById('temp-value');
        const vesselsToggle = document.getElementById('vessels-toggle');
        const o2Toggle = document.getElementById('o2-toggle');
        const co2Toggle = document.getElementById('co2-toggle');

        const skinRespValueDisplay = document.getElementById('skin-resp-value');
        const lungRespValueDisplay = document.getElementById('lung-resp-value');
        const bodyTempValueDisplay = document.getElementById('body-temp-value');

        const skinSpecificControls = document.querySelectorAll('.skin-specific-controls');
        const skinInfo = document.getElementById('skin-info');

        // --- Simulation State Variables ---
        let state = {
            isSubmerged: false,
            hasMucus: false,
            outsideTemp: 20,
            bodyTemp: 20.0,
            showVessels: true,
            showO2: true,
            showCO2: true,
            skinRespPercent: 20,
            lungRespPercent: 80,
            currentView: 'frog', // 'frog' or 'skin'
            waterCoolingApplied: false, // Flag for temporary water cooling
            isMouthTemporarilyClosed: false, // Flag for mouth animation
            mouthStateTimer: 0 // Timer for mouth animation state
        };

        let particles = []; // Array to hold particle objects {x, y, type, color, label, vx, vy}
        let capillaryNetworkData = []; // Store generated capillary paths
        let mucusGlandData = []; // Store generated mucus gland positions/sizes
        let fatLobuleData = []; // Store generated fat lobule positions/sizes

        // --- Frog Image Loading ---
        let frogSittingImage = null; // Renamed from frogImage
        let sittingFrogLoaded = false; // Renamed from frogImageLoaded
        let frogOpenMouthImage = null;
        let openMouthFrogLoaded = false;

        // --- Temperature Control ---
        let tempUpdateTimeout = null;
        let targetOutsideTemp = state.outsideTemp; // Target temp set by slider

        // --- Submersion Animation ---
        let isTransitioningWater = false;
        let waterLevelTarget = 0; // 0 = out, 1 = submerged
        let currentWaterLevel = 0; // 0 to 1, represents transition progress
        const SUBMERGE_DURATION = 4500; // ms for full transition
        let lastTimestamp = 0;

        const MOUTH_OPEN_DURATION = 4000; // ms (2 seconds)
        const MOUTH_CLOSED_DURATION = 2000; // ms (8 seconds)

        const TEMP_LAG_FACTOR = 0.0025; // How quickly body temp adjusts (even slower)
        const WATER_COOLING_DROP = 3; // Initial temp drop when submerged (degrees C)
        const RESPIRATION_START_INCREASE_THRESHOLD = 0.3; // Start increasing skin resp above this
        const RESPIRATION_START_DECREASE_THRESHOLD = 0.7; // Start decreasing skin resp below this
        const MAX_PARTICLES = 50;
        const PARTICLE_RADIUS = 8;
        const PARTICLE_SPEED = 0.5;
        const O2_COLOR = 'red';
        const CO2_COLOR = 'black';
        const PARTICLE_TEXT_COLOR = 'white';
        const arteryColor = '#DC143C'; // Crimson (Global Scope)
        const veinColor = '#1E90FF'; // DodgerBlue (Global Scope)

        const CO2_RELEASE_PROBABILITY = 0.005; // Increased chance per blue vessel segment per frame
        const MAX_O2_PARTICLES = 30; // Target number of O2 particles externally
        const EXTERNAL_CO2_SPAWN_CHANCE_PER_FRAME = 0.0005; // Very low chance to spawn CO2 externally each frame

        // --- Particle Initialization ---
        function initParticles() {
            particles = [];
            const { width, height } = frogCanvas; 
            const spawnZoneHeight = height * 0.3; // Spawn in top 30%

            for (let i = 0; i < MAX_O2_PARTICLES; i++) { // Use MAX_O2_PARTICLES for initial O2 count
                particles.push({
                    x: Math.random() * width,
                    y: Math.random() * spawnZoneHeight,
                    type: 'O2', // Force type to O2
                    color: O2_COLOR, // Force color
                    label: 'O₂', // Force label
                    vx: (Math.random() - 0.5) * PARTICLE_SPEED * 2,
                    vy: (Math.random()) * PARTICLE_SPEED // Initial downward bias
                });
            }
        }

        // --- Canvas Setup ---
        function resizeCanvases() {
            const container = document.querySelector('.canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            frogCanvas.width = width;
            frogCanvas.height = height;
            skinCanvas.width = width;
            skinCanvas.height = height;

            // --- Generate Static Capillary Network Data ---
            capillaryNetworkData = []; // Clear previous data
            const numMainPairs = 2; // Number of Red/Blue pairs
            const numBranchesPerMain = 16; // Branches per main vessel (Increased)
            // Define thicknesses relative to height - Dermis largest
            const epidermisThickness = height * 0.05;
            const dermisThickness = height * 0.40; // Much thicker dermis
            const hypodermisThickness = height * 0.10; // Thinner hypodermis
            const muscleThickness = height * 0.10; // Thinner muscle
            const epidermisY = height * 0.20; // Start reasonably high
            const dermisY = epidermisY + epidermisThickness; 
            const dermisBottomY = dermisY + dermisThickness;
            const hypodermisY = dermisBottomY; 
            const muscleY = hypodermisY + hypodermisThickness; 

            const mainVesselLineWidth = 3;
            const capillaryLineWidth = 1;
            // const arteryColor = '#DC143C'; // Already global
            // const veinColor = '#1E90FF'; // Already global

            for (let pair = 0; pair < numMainPairs; pair++) {
                // Calculate base Y for this pair, spaced within the *new* dermis thickness
                const pairBaseY = dermisY + dermisThickness * (0.25 + pair * 0.5);
                const arteryY = pairBaseY;
                const veinY = pairBaseY + dermisThickness * 0.10; // Adjust spacing relative to dermis thickness

                // --- Create Main Artery (Red) ---
                const arteryCY = arteryY + (Math.random() - 0.5) * dermisThickness * 0.1;
                capillaryNetworkData.push({ 
                    sx: 0, sy: arteryY, cx: width * 0.5, cy: arteryCY, ex: width, ey: arteryY, 
                    color: arteryColor, lw: mainVesselLineWidth 
                });

                // --- Create Main Vein (Blue) ---
                 const veinCY = veinY + (Math.random() - 0.5) * dermisThickness * 0.1;
                 capillaryNetworkData.push({ 
                     sx: 0, sy: veinY, cx: width * 0.5, cy: veinCY, ex: width, ey: veinY, 
                     color: veinColor, lw: mainVesselLineWidth 
                 });

                // --- Create Capillary Branches --- 
                for (let i = 0; i < numBranchesPerMain; i++) {
                    // Branch from Artery
                    const branchStartX_A = (width / numBranchesPerMain) * (i + Math.random() * 0.8);
                    const branchStartY_A = arteryY + (Math.random() - 0.5) * 5;
                    let verticalShift_A = dermisThickness * (0.2 + Math.random() * 0.4); // Scale shift by dermis thickness
                    if (Math.random() < 0.5) verticalShift_A *= -1;
                    // Clamp within new dermis bounds (dermisY to dermisBottomY)
                    const branchEndY_A = Math.max(dermisY + 5, Math.min(dermisBottomY - 5, branchStartY_A + verticalShift_A)); 
                    const branchEndX_A = branchStartX_A + (Math.random() - 0.5) * 30;
                    const branchCX_A = branchStartX_A + (branchEndX_A - branchStartX_A) * 0.5;
                    const branchCY_A = branchStartY_A + (branchEndY_A - branchStartY_A) * (0.3 + Math.random() * 0.4);
                    capillaryNetworkData.push({ 
                        sx: branchStartX_A, sy: branchStartY_A, cx: branchCX_A, cy: branchCY_A, ex: branchEndX_A, ey: branchEndY_A, 
                        color: arteryColor, lw: capillaryLineWidth 
                    });

                    // Branch from Vein
                    const branchStartX_V = (width / numBranchesPerMain) * (i + Math.random() * 0.8);
                    const branchStartY_V = veinY + (Math.random() - 0.5) * 5; 
                    let verticalShift_V = dermisThickness * (0.2 + Math.random() * 0.4); // Scale shift by dermis thickness
                    if (Math.random() < 0.5) verticalShift_V *= -1;
                     // Clamp within new dermis bounds (dermisY to dermisBottomY)
                    const branchEndY_V = Math.max(dermisY + 5, Math.min(dermisBottomY - 5, branchStartY_V + verticalShift_V)); 
                    const branchEndX_V = branchStartX_V + (Math.random() - 0.5) * 30;
                    const branchCX_V = branchStartX_V + (branchEndX_V - branchStartX_V) * 0.5;
                    const branchCY_V = branchStartY_V + (branchEndY_V - branchStartY_V) * (0.3 + Math.random() * 0.4);
                     capillaryNetworkData.push({ 
                         sx: branchStartX_V, sy: branchStartY_V, cx: branchCX_V, cy: branchCY_V, ex: branchEndX_V, ey: branchEndY_V, 
                         color: veinColor, lw: capillaryLineWidth 
                     });
                }
            }
            console.log(`Generated ${capillaryNetworkData.length} static vessel segments.`);
            // ----------------------------------------

            // --- Generate Static Mucus Gland Data ---
            mucusGlandData = [];
            const numGlands = 15;
            const glandColor = 'rgba(170, 190, 200, 0.6)'; // Light blue-grey, semi-transparent
            const ductColor = 'rgba(150, 170, 180, 0.7)'; // Slightly darker for duct
            // const mucusThicknessForDuct = epidermisThickness * 0.4; // No longer needed here
            // const outerSurfaceY = epidermisY - mucusThicknessForDuct; // No longer needed here

            for (let i = 0; i < numGlands; i++) {
                const glandX = Math.random() * width;
                const glandY = dermisY + dermisThickness * (0.1 + Math.random() * 0.8);
                const glandRadius = 8 + Math.random() * 6; // Much larger glands
                
                let glandData = { x: glandX, y: glandY, radius: glandRadius, color: glandColor, hasDuct: false };

                // Randomly give about half the glands a duct - REMOVE RANDOMNESS
                // if (Math.random() < 0.5) { 
                    glandData.hasDuct = true; // All glands have ducts now
                    glandData.ductEndX = glandX + (Math.random() - 0.5) * 10; // Slight horizontal variance at exit
                    glandData.ductEndY = epidermisY; // Duct ENDS exactly at epidermis surface
                    glandData.ductColor = ductColor;
                // }

                mucusGlandData.push(glandData);
            }
            console.log(`Generated ${mucusGlandData.length} static mucus glands.`);
            // ----------------------------------------

            // --- Generate Static Fat Lobule Data ---
            fatLobuleData = [];
            const numFatLobules = 30;
            for (let i = 0; i < numFatLobules; i++) {
                const fatX = Math.random() * width;
                const fatY = hypodermisY + Math.random() * hypodermisThickness;
                const fatRadius = 2 + Math.random() * 3;
                fatLobuleData.push({ x: fatX, y: fatY, radius: fatRadius });
            }
            console.log(`Generated ${fatLobuleData.length} static fat lobules.`);
            // ----------------------------------------

            // Redraw necessary elements after resize
            draw(); 
        }

        // --- Drawing Functions ---
        function drawFrogView() {
            const ctx = frogCtx;
            const { width, height } = frogCanvas;

            // Clear canvas
            ctx.fillStyle = '#d0e0d0'; // Match container background
            ctx.fillRect(0, 0, width, height);

            // Draw simple ground
            ctx.fillStyle = '#8b4513'; // Brown
            ctx.fillRect(0, height * 0.7, width, height * 0.3);

            // --- Select Frog Image based on Water Level AND Timed Mouth State ---
            let activeFrogImage = null;
            let activeFrogLoaded = false;

            const isSubmergedForImage = currentWaterLevel >= 0.58;
            // Use open mouth only if NOT submerged AND mouth is NOT temporarily closed
            let useOpenMouthImage = !isSubmergedForImage && !state.isMouthTemporarilyClosed;
            let imageName = ""; // For logging

            // Try to use Open Mouth image based on combined state
            if (useOpenMouthImage && openMouthFrogLoaded) {
                activeFrogImage = frogOpenMouthImage;
                activeFrogLoaded = true;
                imageName = "Open Mouth";
            } 
            // Otherwise (submerged OR temporarily closed OR open mouth not loaded) try to use Closed Mouth image
            else if (sittingFrogLoaded) { 
                activeFrogImage = frogSittingImage;
                activeFrogLoaded = true;
                imageName = isSubmergedForImage ? "Closed Mouth (Submerged)" : "Closed Mouth (Timed)";
            }
             console.log(`Drawing Frog. Submerged: ${isSubmergedForImage}, Mouth Closed Timer: ${state.isMouthTemporarilyClosed}, Image: ${imageName}`); // Keep this log active for now

            // --- Draw Selected Frog Image (if loaded) ---
            if (activeFrogLoaded && activeFrogImage) {
                // Calculate aspect ratio and desired size/position based on the ACTIVE image
                const aspectRatio = activeFrogImage.naturalWidth / activeFrogImage.naturalHeight;
                let drawWidth = width * 0.3; // Adjust scale as needed
                let drawHeight = drawWidth / aspectRatio;
                // Keep height reasonable if image is very tall
                if (drawHeight > height * 0.5) {
                    drawHeight = height * 0.5;
                    drawWidth = drawHeight * aspectRatio;
                }
                const drawX = (width - drawWidth) / 2;
                const drawY = height * 0.7 - drawHeight + (height * 0.20); // Keep existing offset

                ctx.drawImage(activeFrogImage, drawX, drawY, drawWidth, drawHeight);
            } 

            // Draw water based on current transition level
            if (currentWaterLevel > 0) {
                 const maxWaterHeight = height * 0.6; // Max height when fully submerged
                 const waterHeight = maxWaterHeight * currentWaterLevel; // Animate height
                 const waterY = height - waterHeight; // Start from bottom and rise up
                 ctx.fillStyle = 'rgba(0, 120, 180, 0.3)'; // Semi-transparent blue-green tint
                 ctx.fillRect(0, waterY, width, waterHeight);
            }
        }

        function drawSkinView() {
            const ctx = skinCtx;
            const { width, height } = skinCanvas;
            
            // Define layer thicknesses and Y positions - CONSISTENT WITH resizeCanvases
            const epidermisThickness = height * 0.05;
            const dermisThickness = height * 0.40; // Much thicker dermis
            const hypodermisThickness = height * 0.10; 
            const muscleThickness = height * 0.10;
            
            const epidermisY = height * 0.20; 
            const dermisY = epidermisY + epidermisThickness; 
            const hypodermisY = dermisY + dermisThickness;
            const muscleY = hypodermisY + hypodermisThickness;
            const dermisBottomY = dermisY + dermisThickness; 

            // Clear canvas
            ctx.fillStyle = '#f8f8f8'; // Lighter background
            ctx.fillRect(0, 0, width, height);

            // Draw Muscle Layer (Bottom) - Fills remaining space
            ctx.fillStyle = '#C06060'; // Muted red/pink for muscle
            ctx.fillRect(0, muscleY, width, height - muscleY); // Calculate height dynamically
             ctx.fillStyle = '#800000'; // Darker text for contrast
             ctx.font = '12px sans-serif';
             ctx.textAlign = 'left';
             ctx.fillText('კუნთი', 10, muscleY + 20); // Muscle -> კუნთი

             // Draw Hypodermis Layer
             ctx.fillStyle = '#FFFACD'; // Lemon chiffon for fatty tissue
             ctx.fillRect(0, hypodermisY, width, hypodermisThickness);
             // Add simple fat lobules (circles)
             ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'; // Semi-transparent yellow
             // const numFatLobules = 30; // Moved generation to resizeCanvases
             // Draw pre-generated fat lobules
             fatLobuleData.forEach(fat => {
                 ctx.beginPath();
                 ctx.arc(fat.x, fat.y, fat.radius, 0, Math.PI * 2);
                 ctx.fill();
             });
             ctx.fillStyle = '#B8860B'; // DarkGoldenrod text
             ctx.fillText('ცხიმი', 10, hypodermisY + 20); // Fat -> ცხიმი

            // Draw Dermis (Uses existing logic but new position/thickness)
            ctx.fillStyle = '#ffdab9'; // Peach puff
            ctx.fillRect(0, dermisY, width, dermisThickness);
            ctx.strokeStyle = '#d2b48c'; // Tan border
            ctx.strokeRect(0, dermisY, width, dermisThickness);
            ctx.fillStyle = '#8b4513';
            ctx.textAlign = 'left'; // Ensure alignment is reset
            ctx.textBaseline = 'middle'; // Align text vertically to its middle
            ctx.fillText('დერმა', 10, dermisY + epidermisThickness / 2); // Position at vertical center of layer
            ctx.textBaseline = 'alphabetic'; // Reset baseline for other text
            // --------------------------------------------

            // --- Draw Blood Vessels (if shown) ---
            if (state.showVessels) {
                // Draw the pre-generated static capillaries/vessels
                capillaryNetworkData.forEach(v => {
                    ctx.beginPath();
                    ctx.moveTo(v.sx, v.sy);
                    // Use the stored line width (lw) from generated data
                    ctx.lineWidth = v.lw; 
                    ctx.quadraticCurveTo(v.cx, v.cy, v.ex, v.ey);
                    ctx.strokeStyle = v.color;
                    ctx.stroke();
                });

                 // Reset line width for other strokes (important!)
                 ctx.lineWidth = 1; 
            }

             // --- Draw Epidermis (BEFORE Glands/Ducts) ---
            ctx.fillStyle = '#ffe4e1'; // Misty rose
            ctx.fillRect(0, epidermisY, width, epidermisThickness);
            ctx.strokeStyle = '#cd5c5c'; // Indian red border
            ctx.strokeRect(0, epidermisY, width, epidermisThickness);
            ctx.fillStyle = '#8b0000';
            ctx.textAlign = 'left'; // Ensure alignment is reset
            ctx.textBaseline = 'middle'; // Align text vertically to its middle
            ctx.fillText('ეპიდერმისი', 10, epidermisY + epidermisThickness / 2); // Position at vertical center of layer
            ctx.textBaseline = 'alphabetic'; // Reset baseline for other text
            // --------------------------------------------

            // --- Draw Mucus Glands and Ducts (AFTER Epidermis) ---
            if (state.hasMucus) {
                // Draw the main mucus layer
                const mucusThickness = epidermisThickness * 0.4; 
                const mucusY = epidermisY - mucusThickness;
                ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; 
                ctx.fillRect(0, mucusY, width, mucusThickness);
                ctx.strokeStyle = 'rgba(100, 149, 237, 0.7)'; 
                 ctx.strokeRect(0, mucusY, width, mucusThickness);
                 ctx.fillStyle = '#00008b';
                 ctx.fillText('ლორწო', 10, mucusY + mucusThickness * 0.75); // Mucus -> ლორწო

                 // Draw Mucus Glands & Ducts (Now only when mucus is ON)
                 mucusGlandData.forEach(gland => {
                     // Draw Gland Body
                     ctx.beginPath();
                     ctx.arc(gland.x, gland.y, gland.radius, 0, Math.PI * 2);
                     ctx.fillStyle = gland.color;
                     ctx.fill();
    
                     // Draw Duct if it exists
                     if (gland.hasDuct) {
                         ctx.beginPath();
                         ctx.moveTo(gland.x, gland.y - gland.radius); 
                         ctx.lineTo(gland.ductEndX, gland.ductEndY);
                         ctx.strokeStyle = gland.ductColor;
                         ctx.lineWidth = 3; 
                         ctx.stroke();
                     }
                 });
                 // Reset line width
                 ctx.lineWidth = 1;

                 // Draw Mucus Secretion Cue at Duct Endings
                 const secretionColor = 'rgba(135, 206, 250, 0.8)'; // LightSkyBlue, more opaque
                 mucusGlandData.forEach(gland => {
                     if (gland.hasDuct) {
                         ctx.beginPath();
                         ctx.arc(gland.ductEndX, gland.ductEndY, 3, 0, Math.PI * 2); // Small circle at duct end
                         ctx.fillStyle = secretionColor;
                         ctx.fill();
                     }
                 });
            }

            // --- Draw Particles --- (Need to update particle logic separately)
            drawParticles(ctx, width, height, epidermisY, epidermisThickness);

            // --- Draw water/air overlay ---
            const skinSurfaceY = state.hasMucus ? epidermisY - (epidermisThickness * 0.2) : epidermisY;
            if (currentWaterLevel > 0) {
                // Water overlay above the skin surface - animate height from skin surface up
                const waterOverlayHeight = skinSurfaceY * currentWaterLevel;
                const waterOverlayY = skinSurfaceY - waterOverlayHeight; // Calculate top Y position
                ctx.fillStyle = 'rgba(0, 120, 180, 0.3)'; // Lighter blue-green overlay tint
                ctx.fillRect(0, waterOverlayY, width, waterOverlayHeight); // Draw from calculated Y

                 ctx.fillStyle = '#0000cd'; // Keep text blue
                 ctx.textAlign = 'center';
                 ctx.font = '14px sans-serif';
                 ctx.fillText('წყალი', width / 2, 30); // Water -> წყალი
            } else if (!isTransitioningWater) { // Only draw Air if not transitioning
                // Indicate Air
                 ctx.fillStyle = '#87ceeb'; // Sky blue indication
                 ctx.textAlign = 'center';
                 ctx.font = '14px sans-serif';
                 ctx.fillText('ჰაერი', width / 2, 30); // Air -> ჰაერი
            }

        }

        function drawParticles(ctx, width, height, epidermisY, layerThickness) {
            const skinSurfaceY = state.hasMucus ? epidermisY - (layerThickness * 0.2) : epidermisY;
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            particles.forEach(p => {
                // Check visibility toggle
                if ((p.type === 'O2' && state.showO2) || (p.type === 'CO2' && state.showCO2)) {
                    // Only draw particles above the skin or just entering
                    if (p.y < epidermisY + layerThickness) { 
                         ctx.fillStyle = p.color;
                         ctx.beginPath();
                         ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
                         ctx.fill();

                         // Draw text label
                         ctx.fillStyle = PARTICLE_TEXT_COLOR;
                         ctx.fillText(p.label, p.x, p.y);
                     }
                }
            });
        }

        function draw() {
            if (state.currentView === 'frog') {
                drawFrogView();
            } else {
                drawSkinView();
            }
        }

        // --- Update Functions ---
        function updateDashboard() {
            skinRespValueDisplay.textContent = `${Math.round(state.skinRespPercent)}%`;
            lungRespValueDisplay.textContent = `${Math.round(state.lungRespPercent)}%`;
            bodyTempValueDisplay.textContent = `${state.bodyTemp.toFixed(1)}°C`;
        }

        function updateSimulationState(deltaTime) {
            // Temperature adjustment - uses state.outsideTemp which is updated with delay
            const tempDifference = state.outsideTemp - state.bodyTemp;
            // Mucus provides slight insulation against outside temp changes
            const mucusInsulation = state.hasMucus ? 0.5 : 1.0;
            let tempChange = tempDifference * TEMP_LAG_FACTOR * mucusInsulation; // Apply mucus insulation here

            // Check for submersion threshold crossing for temporary cooling
            const isSubmergedThreshold = currentWaterLevel >= 0.58;

            if (isSubmergedThreshold && !state.waterCoolingApplied) {
                // Apply temporary cooling drop ONCE per submersion
                state.bodyTemp -= WATER_COOLING_DROP;
                state.waterCoolingApplied = true;
                console.log(`Applying water cooling drop. New temp: ${state.bodyTemp.toFixed(1)}°C`);
            } else if (!isSubmergedThreshold) {
                // Reset the flag when the frog is no longer submerged
                if (state.waterCoolingApplied) {
                    console.log('Resetting water cooling flag.');
                    state.waterCoolingApplied = false; 
                }
            }

            // Apply the gradual temperature change towards outside temp
            state.bodyTemp += tempChange;
            
            // Clamp temperature within reasonable biological limits if needed (e.g., 0-40)
            state.bodyTemp = Math.max(0, Math.min(40, state.bodyTemp));

            // --- Respiration adjustment with Reversed Hysteresis Thresholds ---
            const baseLung = 80;
            const baseSkin = 20;
            // Mucus boost only applied when below the lower threshold
            const effectiveMucusBoost = (currentWaterLevel < RESPIRATION_START_INCREASE_THRESHOLD && state.hasMucus) ? 5 : 0;
            const baseSkinWithBoost = baseSkin + effectiveMucusBoost; // Base starting point for scaling

            if (currentWaterLevel < RESPIRATION_START_INCREASE_THRESHOLD) {
                // Below lower threshold (0.3): Use base skin respiration
                state.skinRespPercent = baseSkinWithBoost;
            } else if (currentWaterLevel >= RESPIRATION_START_DECREASE_THRESHOLD) {
                // Above upper threshold (0.7): Use 100% skin respiration
                state.skinRespPercent = 100;
            } else {
                // Between thresholds (0.3 <= level < 0.7): Linearly scale from base to 100%
                const transitionRange = RESPIRATION_START_DECREASE_THRESHOLD - RESPIRATION_START_INCREASE_THRESHOLD;
                const progressInTransition = (currentWaterLevel - RESPIRATION_START_INCREASE_THRESHOLD) / transitionRange;
                const totalPercentIncrease = 100 - baseSkinWithBoost; // Max increase needed
                // Apply linear scaling within the transition zone
                state.skinRespPercent = baseSkinWithBoost + (totalPercentIncrease * progressInTransition);
            }
            
            // Ensure percentages are clamped and lungs are the remainder
            state.skinRespPercent = Math.max(0, Math.min(100, state.skinRespPercent));
            state.lungRespPercent = 100 - state.skinRespPercent;

            // Update particles only when in skin view
            if (state.currentView === 'skin') {
                updateParticles();
            }

            // --- Mouth Animation Timer ---
            if (currentWaterLevel < 0.58) { // Only run timer when not submerged
                 console.log(`Mouth timer running. Current timer: ${state.mouthStateTimer.toFixed(0)}, IsClosed: ${state.isMouthTemporarilyClosed}`); // DEBUG LOG
                state.mouthStateTimer += deltaTime;
                if (state.isMouthTemporarilyClosed) {
                    if (state.mouthStateTimer >= MOUTH_CLOSED_DURATION) {
                        console.log("[Mouth Timer] Opening mouth"); // LOG
                        state.isMouthTemporarilyClosed = false;
                        state.mouthStateTimer = 0; // Reset timer for open state
                    }
                } else { // Mouth is currently open - RE-ADD THIS ELSE BLOCK
                    if (state.mouthStateTimer >= MOUTH_OPEN_DURATION) {
                         console.log("[Mouth Timer] Closing mouth"); // LOG
                        state.isMouthTemporarilyClosed = true;
                        state.mouthStateTimer = 0; // Reset timer for closed state
                    }
                }
            } else {
                // Ensure mouth is open image when submerged & reset timer if needed
                state.isMouthTemporarilyClosed = false;
                state.mouthStateTimer = 0;
            }
        }

        function updateParticles() {
            const { width, height } = skinCanvas;
             // Define thicknesses and Y positions consistent with drawing
            const epidermisThickness = height * 0.05;
            const dermisThickness = height * 0.40; // Match updated thickness
            const epidermisY = height * 0.20; // Match updated Y
            const dermisY = epidermisY + epidermisThickness;
            const mucusThickness = epidermisThickness * 0.4;
            const mucusY = epidermisY - mucusThickness; 
            const skinSurfaceY = state.hasMucus ? mucusY : epidermisY; // Actual outer surface
            const dermisBottomY = dermisY + dermisThickness; // Bottom edge of dermis

            // Iterate backwards for safe splicing
            try { // Add try block for error catching
                for (let index = particles.length - 1; index >= 0; index--) {
                    const p = particles[index];
                    if (!p) {
                         console.error("Attempted to process undefined particle at index:", index); 
                         continue; // Skip this iteration if particle is undefined
                    }

                // Basic Movement
                p.x += p.vx;
                p.y += p.vy;

                // Wall collision (simple bounce/wrap)
                if (p.x < PARTICLE_RADIUS || p.x > width - PARTICLE_RADIUS) {
                    p.vx *= -1;
                    p.x = Math.max(PARTICLE_RADIUS, Math.min(width - PARTICLE_RADIUS, p.x)); // Clamp
                }
                 // Keep particles mostly above the dermis for visualization
                if (p.y < PARTICLE_RADIUS) {
                    p.vy *= -1;
                    p.y = PARTICLE_RADIUS;
                    } else if (p.y > dermisBottomY - PARTICLE_RADIUS) { // Bounce off CORRECT BOTTOM of dermis
                    p.vy *= -1;
                        p.y = dermisBottomY - PARTICLE_RADIUS - 1; // Clamp slightly above bottom boundary
                    }

                    // --- O2 Absorption by Red Vessels --- (Check should still use epidermisY as lower bound)
                    let absorbed = false;
                    if (p.type === 'O2' && state.showVessels && p.y > epidermisY) { 
                        for (const vessel of capillaryNetworkData) {
                            // Check only against red vessels (arteries/arterioles)
                            if (vessel.color === arteryColor) { // Match exact artery color
                                const vesselMidX = (vessel.sx + vessel.ex) / 2;
                                const vesselMidY = (vessel.sy + vessel.ey) / 2;
                                const dx = p.x - vesselMidX;
                                const dy = p.y - vesselMidY;
                                const distanceSq = dx*dx + dy*dy;
                                const collisionRadius = PARTICLE_RADIUS + (vessel.lw / 2) + 2; 
                                
                                if (distanceSq < collisionRadius * collisionRadius) {
                                    particles.splice(index, 1); 
                                    absorbed = true;
                                    // console.log('O2 absorbed by vessel');
                                    break; 
                                }
                            }
                        }
                    }

                    // --- CO2 Exit at Surface --- (Uses skinSurfaceY)
                     if (!absorbed && p.type === 'CO2') {
                        // const exitSurfaceY = state.hasMucus ? mucusY : epidermisY; // Already defined as skinSurfaceY
                        const exitThresholdY = skinSurfaceY * 0.25; // 75% of the way up from skin surface
                        
                        if (p.y < exitThresholdY - PARTICLE_RADIUS) { 
                     particles.splice(index, 1);
                             // console.log('CO2 exited skin far above');
                        }
                     }
                    
                     // Removed old diffusion logic that respawned random particles near surface
                     
                } // End backward for loop
            } catch (error) {
                 console.error("Error within particle processing loop:", error);
                 // Keep the simulation running by catching the error, 
                 // but log it so we know what went wrong.
            }

             // --- Particle Count Maintenance ---
             // Ensure target number of O2 particles are present externally, only if O2 and Vessels are shown
             if (state.showO2 && state.showVessels) {
                 let currentO2Count = particles.filter(p => p.type === 'O2' && p.y < epidermisY).length; // Count only external O2 (above epidermis)
                 while (currentO2Count < MAX_O2_PARTICLES && particles.length < MAX_PARTICLES * 1.5) {
                     particles.push({
                         x: Math.random() * width,
                         y: Math.random() * (height * 0.1), // Respawn near top
                         type: 'O2',
                         color: O2_COLOR,
                         label: 'O₂',
                         vx: (Math.random() - 0.5) * PARTICLE_SPEED * 2,
                         vy: PARTICLE_SPEED * (0.5 + Math.random()) // Bias downward
                     });
                     currentO2Count++;
                 }
             }

            // --- CO2 Release from Blue Vessels ---
             if (state.showVessels && state.showCO2) { // Only release if vessels & CO2 are visible
                 capillaryNetworkData.forEach(vessel => {
                     // Check only blue vessels (veins/venules)
                     if ((vessel.color === veinColor || vessel.color === '#4682B4' || vessel.color === '#00BFFF') && 
                         Math.random() < CO2_RELEASE_PROBABILITY &&
                         particles.length < MAX_PARTICLES * 1.2) { // Prevent excessive particles
                         
                         // Spawn near the middle of the vessel segment
                         const spawnX = (vessel.sx + vessel.ex) / 2 + (Math.random() - 0.5) * 5;
                         const spawnY = (vessel.sy + vessel.ey) / 2 + (Math.random() - 0.5) * 5;
                         
                         // Calculate initial velocity roughly perpendicular/outwards (mostly upwards)
                         const dx = vessel.ex - vessel.sx;
                         const dy = vessel.ey - vessel.sy;
                         // Basic perpendicular (-dy, dx), normalize roughly & bias upwards
                         let initialVX = -dy;
                         let initialVY = dx;
                         const mag = Math.sqrt(initialVX*initialVX + initialVY*initialVY);
                         if (mag > 0) {
                             initialVX = (initialVX / mag) * PARTICLE_SPEED * (0.5 + Math.random() * 0.5);
                             initialVY = (initialVY / mag) * PARTICLE_SPEED * (0.5 + Math.random() * 0.5);
                         }
                         // Ensure it tends to move upwards out of the vessel
                         initialVY = -Math.abs(initialVY); 

                         particles.push({
                             x: spawnX,
                             y: spawnY,
                             type: 'CO2',
                             color: CO2_COLOR,
                             label: 'CO₂',
                             vx: initialVX,
                             vy: initialVY
                         });
                         // console.log('Released CO2 from vessel');
                     }
                 });
             }

             // --- Occasional External CO2 Spawn ---
             if (state.showCO2 && Math.random() < EXTERNAL_CO2_SPAWN_CHANCE_PER_FRAME && particles.length < MAX_PARTICLES * 1.5) {
                 particles.push({
                     x: Math.random() * width,
                     y: Math.random() * (height * 0.1), // Spawn near top
                     type: 'CO2',
                     color: CO2_COLOR,
                     label: 'CO₂',
                     vx: (Math.random() - 0.5) * PARTICLE_SPEED,
                     vy: PARTICLE_SPEED * (0.5 + Math.random()) // Bias downward
                 });
                // console.log("Spawned external CO2");
            }
        }

         function calculateDiffusionProbability(particleType) {
             let baseProb = 0.005; // Base chance per frame

             // Use currentWaterLevel to determine effect, not just final state.isSubmerged
             const effectivelySubmerged = currentWaterLevel > 0.5; 

             if (particleType === 'O2') {
                 if (effectivelySubmerged) {
                     baseProb *= 10; // Much higher O2 diffusion in water
                 } else {
                     // Slightly higher diffusion with mucus in air
                     if (state.hasMucus) baseProb *= 1.5;
                 }
             } else { // CO2
                 // CO2 diffusion out might be slightly less affected by water/mucus
                 baseProb *= 0.8; 
                 // Maybe slightly increase CO2 out-diffusion when submerged?
                 if (effectivelySubmerged) baseProb *= 1.2;
             }
             return baseProb;
         }

        // --- Event Listeners ---
        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvases);

            viewFrogButton.addEventListener('click', () => switchView('frog'));
            viewSkinButton.addEventListener('click', () => switchView('skin'));

            submergeToggle.addEventListener('click', () => {
                // Initiate transition
                waterLevelTarget = (waterLevelTarget === 0) ? 1 : 0;
                isTransitioningWater = true;
                state.isSubmerged = (waterLevelTarget === 1); // Update final state intention
                updateToggleButton(submergeToggle, state.isSubmerged, 'Submerged');

                // --- Reset particle visibility on water change ---
                state.showO2 = false; // Set to OFF
                state.showCO2 = false; // Set to OFF
                updateToggleButton(o2Toggle, state.showO2, 'O₂');
                updateToggleButton(co2Toggle, state.showCO2, 'CO₂');
                // -------------------------------------------------

                // Actual water level change happens in gameLoop
            });

            mucusToggle.addEventListener('click', () => {
                state.hasMucus = !state.hasMucus;
                updateToggleButton(mucusToggle, state.hasMucus, 'Mucus');
            });

            tempSlider.addEventListener('input', (e) => {
                targetOutsideTemp = parseFloat(e.target.value); // Update target immediately
                tempValueDisplay.textContent = `${targetOutsideTemp}°C`;

                // Clear previous timeout if slider is moved again
                if (tempUpdateTimeout) {
                    clearTimeout(tempUpdateTimeout);
                }

                // Set a new timeout to update the actual outsideTemp after a pause
                tempUpdateTimeout = setTimeout(() => {
                    state.outsideTemp = targetOutsideTemp;
                    console.log(`Outside temp updated to: ${state.outsideTemp}°C`);
                    tempUpdateTimeout = null; // Clear the timeout ID
                }, 500); // 500ms delay after last slider movement
            });

            // Skin specific toggles
             vesselsToggle.addEventListener('click', () => {
                 state.showVessels = !state.showVessels;
                 updateToggleButton(vesselsToggle, state.showVessels, 'Vessels');
                 draw(); // Redraw needed immediately for visual change
             });
             o2Toggle.addEventListener('click', () => {
                 state.showO2 = !state.showO2;
                 updateToggleButton(o2Toggle, state.showO2, 'O₂');
                 // Potentially redraw if particles are implemented
             });
             co2Toggle.addEventListener('click', () => {
                 state.showCO2 = !state.showCO2;
                 updateToggleButton(co2Toggle, state.showCO2, 'CO₂');
                  // Potentially redraw if particles are implemented
             });
        }

        // --- Helper Functions ---
        function switchView(view) {
            state.currentView = view;
            if (view === 'frog') {
                frogCanvas.style.display = 'block';
                skinCanvas.style.display = 'none';
                viewFrogButton.classList.add('active');
                viewSkinButton.classList.remove('active');
                // Hide skin controls
                skinSpecificControls.forEach(el => el.style.display = 'none');
                skinInfo.style.display = 'none';
            } else { // 'skin'
                frogCanvas.style.display = 'none';
                skinCanvas.style.display = 'block';
                viewFrogButton.classList.remove('active');
                viewSkinButton.classList.add('active');
                 // Show skin controls
                skinSpecificControls.forEach(el => el.style.display = 'block');
                skinInfo.style.display = 'block';
            }
            draw(); // Redraw the newly active canvas
        }

        function updateToggleButton(button, isOn, label) {
             // Map original English labels to Georgian translations
             const labelMap = {
                 'Submerged': 'ჩაძირული',
                 'Mucus': 'ლორწო',
                 'Vessels': 'ძარღვები',
                 'O₂': 'O₂',
                 'CO₂': 'CO₂'
             };
             const displayLabel = labelMap[label] || label; // Use Georgian or default
             const status = isOn ? 'კი' : 'არა'; // Georgian for ON/OFF

            if (isOn) {
                button.classList.remove('off');
                button.classList.add('on');
                button.textContent = `${displayLabel}: ${status}`;
            } else {
                button.classList.remove('on');
                button.classList.add('off');
                 button.textContent = `${displayLabel}: ${status}`;
            }
        }

        // --- Simulation Loop ---
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            // --- Water Level Animation ---
            if (isTransitioningWater && deltaTime > 0) {
                const changeAmount = (deltaTime / SUBMERGE_DURATION);
                if (waterLevelTarget > currentWaterLevel) {
                    currentWaterLevel = Math.min(1, currentWaterLevel + changeAmount);
                } else {
                    currentWaterLevel = Math.max(0, currentWaterLevel - changeAmount);
                }

                // Stop transitioning when target is reached
                if (Math.abs(currentWaterLevel - waterLevelTarget) < 0.001) {
                    currentWaterLevel = waterLevelTarget;
                    isTransitioningWater = false;
                    console.log(`Water transition finished. Level: ${currentWaterLevel}`);
                }
            }

            updateSimulationState(deltaTime); // Pass deltaTime if needed for other physics
            updateDashboard();
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        function init() {
            console.log("Initializing simulation...");
            resizeCanvases(); // Initial sizing
            initParticles(); // Initialize particles

            // --- Load Frog Images ---
            // Sitting Frog (Submerged)
            frogSittingImage = new Image();
            frogSittingImage.onload = () => {
                console.log("Sitting frog image loaded successfully.");
                sittingFrogLoaded = true;
                draw(); // Redraw canvases
            };
            frogSittingImage.onerror = () => {
                 console.error("Failed to load frog image from file 'Closed mouth sitting.png'.");
                 // sittingFrogLoaded remains false
            };
            frogSittingImage.src = "Closed mouth sitting.png"; // Use relative path

            // Open Mouth Frog (Not Submerged)
            frogOpenMouthImage = new Image();
            frogOpenMouthImage.onload = () => {
                console.log("Open mouth frog image loaded successfully.");
                openMouthFrogLoaded = true;
                draw(); // Redraw canvases
            };
            frogOpenMouthImage.onerror = () => {
                 console.error("Failed to load frog image from file 'Open mouth sitting.png'.");
                 // openMouthFrogLoaded remains false
            };
            frogOpenMouthImage.src = "Open mouth sitting.png"; // Use relative path
            // ----------------------

            setupEventListeners();
            updateDashboard(); // Set initial values
            switchView('frog'); // Start with frog view
            lastTimestamp = performance.now(); // Initialize timestamp for loop
            requestAnimationFrame(gameLoop); // Start the loop
            console.log("Simulation initialized and loop started.");
        }

        // Wait for the DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
